// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: translator-protobuf.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_translator_2dprotobuf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_translator_2dprotobuf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_translator_2dprotobuf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_translator_2dprotobuf_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_translator_2dprotobuf_2eproto;
namespace translator {
class GetClaimedAddressRequest;
struct GetClaimedAddressRequestDefaultTypeInternal;
extern GetClaimedAddressRequestDefaultTypeInternal _GetClaimedAddressRequest_default_instance_;
class GetClaimedAddressResponse;
struct GetClaimedAddressResponseDefaultTypeInternal;
extern GetClaimedAddressResponseDefaultTypeInternal _GetClaimedAddressResponse_default_instance_;
class ReadDataByIdentifierRequest;
struct ReadDataByIdentifierRequestDefaultTypeInternal;
extern ReadDataByIdentifierRequestDefaultTypeInternal _ReadDataByIdentifierRequest_default_instance_;
class ReadDataByIdentifierResponse;
struct ReadDataByIdentifierResponseDefaultTypeInternal;
extern ReadDataByIdentifierResponseDefaultTypeInternal _ReadDataByIdentifierResponse_default_instance_;
class ReadResponse;
struct ReadResponseDefaultTypeInternal;
extern ReadResponseDefaultTypeInternal _ReadResponse_default_instance_;
class UDSCANFormat;
struct UDSCANFormatDefaultTypeInternal;
extern UDSCANFormatDefaultTypeInternal _UDSCANFormat_default_instance_;
class UDSCloseCommChannelRequest;
struct UDSCloseCommChannelRequestDefaultTypeInternal;
extern UDSCloseCommChannelRequestDefaultTypeInternal _UDSCloseCommChannelRequest_default_instance_;
class UDSCloseCommChannelResponse;
struct UDSCloseCommChannelResponseDefaultTypeInternal;
extern UDSCloseCommChannelResponseDefaultTypeInternal _UDSCloseCommChannelResponse_default_instance_;
class UDSOpenCommChannelRequest;
struct UDSOpenCommChannelRequestDefaultTypeInternal;
extern UDSOpenCommChannelRequestDefaultTypeInternal _UDSOpenCommChannelRequest_default_instance_;
class UDSOpenCommChannelResponse;
struct UDSOpenCommChannelResponseDefaultTypeInternal;
extern UDSOpenCommChannelResponseDefaultTypeInternal _UDSOpenCommChannelResponse_default_instance_;
}  // namespace translator
PROTOBUF_NAMESPACE_OPEN
template<> ::translator::GetClaimedAddressRequest* Arena::CreateMaybeMessage<::translator::GetClaimedAddressRequest>(Arena*);
template<> ::translator::GetClaimedAddressResponse* Arena::CreateMaybeMessage<::translator::GetClaimedAddressResponse>(Arena*);
template<> ::translator::ReadDataByIdentifierRequest* Arena::CreateMaybeMessage<::translator::ReadDataByIdentifierRequest>(Arena*);
template<> ::translator::ReadDataByIdentifierResponse* Arena::CreateMaybeMessage<::translator::ReadDataByIdentifierResponse>(Arena*);
template<> ::translator::ReadResponse* Arena::CreateMaybeMessage<::translator::ReadResponse>(Arena*);
template<> ::translator::UDSCANFormat* Arena::CreateMaybeMessage<::translator::UDSCANFormat>(Arena*);
template<> ::translator::UDSCloseCommChannelRequest* Arena::CreateMaybeMessage<::translator::UDSCloseCommChannelRequest>(Arena*);
template<> ::translator::UDSCloseCommChannelResponse* Arena::CreateMaybeMessage<::translator::UDSCloseCommChannelResponse>(Arena*);
template<> ::translator::UDSOpenCommChannelRequest* Arena::CreateMaybeMessage<::translator::UDSOpenCommChannelRequest>(Arena*);
template<> ::translator::UDSOpenCommChannelResponse* Arena::CreateMaybeMessage<::translator::UDSOpenCommChannelResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace translator {

// ===================================================================

class GetClaimedAddressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:translator.GetClaimedAddressRequest) */ {
 public:
  inline GetClaimedAddressRequest() : GetClaimedAddressRequest(nullptr) {}
  ~GetClaimedAddressRequest() override;
  explicit PROTOBUF_CONSTEXPR GetClaimedAddressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetClaimedAddressRequest(const GetClaimedAddressRequest& from);
  GetClaimedAddressRequest(GetClaimedAddressRequest&& from) noexcept
    : GetClaimedAddressRequest() {
    *this = ::std::move(from);
  }

  inline GetClaimedAddressRequest& operator=(const GetClaimedAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClaimedAddressRequest& operator=(GetClaimedAddressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetClaimedAddressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetClaimedAddressRequest* internal_default_instance() {
    return reinterpret_cast<const GetClaimedAddressRequest*>(
               &_GetClaimedAddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetClaimedAddressRequest& a, GetClaimedAddressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetClaimedAddressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetClaimedAddressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetClaimedAddressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetClaimedAddressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetClaimedAddressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetClaimedAddressRequest& from) {
    GetClaimedAddressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClaimedAddressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "translator.GetClaimedAddressRequest";
  }
  protected:
  explicit GetClaimedAddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIDFieldNumber = 1,
    kSequenceNoFieldNumber = 2,
  };
  // string appID = 1;
  void clear_appid();
  const std::string& appid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appid();
  PROTOBUF_NODISCARD std::string* release_appid();
  void set_allocated_appid(std::string* appid);
  private:
  const std::string& _internal_appid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appid(const std::string& value);
  std::string* _internal_mutable_appid();
  public:

  // string sequenceNo = 2;
  void clear_sequenceno();
  const std::string& sequenceno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceno();
  PROTOBUF_NODISCARD std::string* release_sequenceno();
  void set_allocated_sequenceno(std::string* sequenceno);
  private:
  const std::string& _internal_sequenceno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceno(const std::string& value);
  std::string* _internal_mutable_sequenceno();
  public:

  // @@protoc_insertion_point(class_scope:translator.GetClaimedAddressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceno_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_translator_2dprotobuf_2eproto;
};
// -------------------------------------------------------------------

class GetClaimedAddressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:translator.GetClaimedAddressResponse) */ {
 public:
  inline GetClaimedAddressResponse() : GetClaimedAddressResponse(nullptr) {}
  ~GetClaimedAddressResponse() override;
  explicit PROTOBUF_CONSTEXPR GetClaimedAddressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetClaimedAddressResponse(const GetClaimedAddressResponse& from);
  GetClaimedAddressResponse(GetClaimedAddressResponse&& from) noexcept
    : GetClaimedAddressResponse() {
    *this = ::std::move(from);
  }

  inline GetClaimedAddressResponse& operator=(const GetClaimedAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClaimedAddressResponse& operator=(GetClaimedAddressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetClaimedAddressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetClaimedAddressResponse* internal_default_instance() {
    return reinterpret_cast<const GetClaimedAddressResponse*>(
               &_GetClaimedAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetClaimedAddressResponse& a, GetClaimedAddressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetClaimedAddressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetClaimedAddressResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetClaimedAddressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetClaimedAddressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetClaimedAddressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetClaimedAddressResponse& from) {
    GetClaimedAddressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClaimedAddressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "translator.GetClaimedAddressResponse";
  }
  protected:
  explicit GetClaimedAddressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIDFieldNumber = 1,
    kSequenceNoFieldNumber = 2,
    kClaimedAddressFieldNumber = 3,
    kResponseCodeFieldNumber = 4,
  };
  // string appID = 1;
  void clear_appid();
  const std::string& appid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appid();
  PROTOBUF_NODISCARD std::string* release_appid();
  void set_allocated_appid(std::string* appid);
  private:
  const std::string& _internal_appid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appid(const std::string& value);
  std::string* _internal_mutable_appid();
  public:

  // string sequenceNo = 2;
  void clear_sequenceno();
  const std::string& sequenceno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceno();
  PROTOBUF_NODISCARD std::string* release_sequenceno();
  void set_allocated_sequenceno(std::string* sequenceno);
  private:
  const std::string& _internal_sequenceno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceno(const std::string& value);
  std::string* _internal_mutable_sequenceno();
  public:

  // string claimedAddress = 3;
  void clear_claimedaddress();
  const std::string& claimedaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_claimedaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_claimedaddress();
  PROTOBUF_NODISCARD std::string* release_claimedaddress();
  void set_allocated_claimedaddress(std::string* claimedaddress);
  private:
  const std::string& _internal_claimedaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_claimedaddress(const std::string& value);
  std::string* _internal_mutable_claimedaddress();
  public:

  // string responseCode = 4;
  void clear_responsecode();
  const std::string& responsecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_responsecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_responsecode();
  PROTOBUF_NODISCARD std::string* release_responsecode();
  void set_allocated_responsecode(std::string* responsecode);
  private:
  const std::string& _internal_responsecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsecode(const std::string& value);
  std::string* _internal_mutable_responsecode();
  public:

  // @@protoc_insertion_point(class_scope:translator.GetClaimedAddressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceno_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr claimedaddress_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responsecode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_translator_2dprotobuf_2eproto;
};
// -------------------------------------------------------------------

class UDSCANFormat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:translator.UDSCANFormat) */ {
 public:
  inline UDSCANFormat() : UDSCANFormat(nullptr) {}
  ~UDSCANFormat() override;
  explicit PROTOBUF_CONSTEXPR UDSCANFormat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UDSCANFormat(const UDSCANFormat& from);
  UDSCANFormat(UDSCANFormat&& from) noexcept
    : UDSCANFormat() {
    *this = ::std::move(from);
  }

  inline UDSCANFormat& operator=(const UDSCANFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDSCANFormat& operator=(UDSCANFormat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UDSCANFormat& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDSCANFormat* internal_default_instance() {
    return reinterpret_cast<const UDSCANFormat*>(
               &_UDSCANFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UDSCANFormat& a, UDSCANFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(UDSCANFormat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDSCANFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDSCANFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDSCANFormat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UDSCANFormat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UDSCANFormat& from) {
    UDSCANFormat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UDSCANFormat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "translator.UDSCANFormat";
  }
  protected:
  explicit UDSCANFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCanPhysReqFormatFieldNumber = 1,
    kCanRespUSDTFormatFieldNumber = 2,
  };
  // string canPhysReqFormat = 1;
  void clear_canphysreqformat();
  const std::string& canphysreqformat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_canphysreqformat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_canphysreqformat();
  PROTOBUF_NODISCARD std::string* release_canphysreqformat();
  void set_allocated_canphysreqformat(std::string* canphysreqformat);
  private:
  const std::string& _internal_canphysreqformat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_canphysreqformat(const std::string& value);
  std::string* _internal_mutable_canphysreqformat();
  public:

  // string canRespUSDTFormat = 2;
  void clear_canrespusdtformat();
  const std::string& canrespusdtformat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_canrespusdtformat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_canrespusdtformat();
  PROTOBUF_NODISCARD std::string* release_canrespusdtformat();
  void set_allocated_canrespusdtformat(std::string* canrespusdtformat);
  private:
  const std::string& _internal_canrespusdtformat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_canrespusdtformat(const std::string& value);
  std::string* _internal_mutable_canrespusdtformat();
  public:

  // @@protoc_insertion_point(class_scope:translator.UDSCANFormat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr canphysreqformat_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr canrespusdtformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_translator_2dprotobuf_2eproto;
};
// -------------------------------------------------------------------

class UDSOpenCommChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:translator.UDSOpenCommChannelRequest) */ {
 public:
  inline UDSOpenCommChannelRequest() : UDSOpenCommChannelRequest(nullptr) {}
  ~UDSOpenCommChannelRequest() override;
  explicit PROTOBUF_CONSTEXPR UDSOpenCommChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UDSOpenCommChannelRequest(const UDSOpenCommChannelRequest& from);
  UDSOpenCommChannelRequest(UDSOpenCommChannelRequest&& from) noexcept
    : UDSOpenCommChannelRequest() {
    *this = ::std::move(from);
  }

  inline UDSOpenCommChannelRequest& operator=(const UDSOpenCommChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDSOpenCommChannelRequest& operator=(UDSOpenCommChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UDSOpenCommChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDSOpenCommChannelRequest* internal_default_instance() {
    return reinterpret_cast<const UDSOpenCommChannelRequest*>(
               &_UDSOpenCommChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UDSOpenCommChannelRequest& a, UDSOpenCommChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UDSOpenCommChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDSOpenCommChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDSOpenCommChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDSOpenCommChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UDSOpenCommChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UDSOpenCommChannelRequest& from) {
    UDSOpenCommChannelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UDSOpenCommChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "translator.UDSOpenCommChannelRequest";
  }
  protected:
  explicit UDSOpenCommChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCanFormatFieldNumber = 5,
    kAppIDFieldNumber = 1,
    kSequenceNoFieldNumber = 2,
    kToolAddressFieldNumber = 3,
    kEcuAddressFieldNumber = 4,
    kResourceNameFieldNumber = 6,
  };
  // repeated .translator.UDSCANFormat canFormat = 5;
  int canformat_size() const;
  private:
  int _internal_canformat_size() const;
  public:
  void clear_canformat();
  ::translator::UDSCANFormat* mutable_canformat(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::translator::UDSCANFormat >*
      mutable_canformat();
  private:
  const ::translator::UDSCANFormat& _internal_canformat(int index) const;
  ::translator::UDSCANFormat* _internal_add_canformat();
  public:
  const ::translator::UDSCANFormat& canformat(int index) const;
  ::translator::UDSCANFormat* add_canformat();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::translator::UDSCANFormat >&
      canformat() const;

  // string appID = 1;
  void clear_appid();
  const std::string& appid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appid();
  PROTOBUF_NODISCARD std::string* release_appid();
  void set_allocated_appid(std::string* appid);
  private:
  const std::string& _internal_appid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appid(const std::string& value);
  std::string* _internal_mutable_appid();
  public:

  // string sequenceNo = 2;
  void clear_sequenceno();
  const std::string& sequenceno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceno();
  PROTOBUF_NODISCARD std::string* release_sequenceno();
  void set_allocated_sequenceno(std::string* sequenceno);
  private:
  const std::string& _internal_sequenceno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceno(const std::string& value);
  std::string* _internal_mutable_sequenceno();
  public:

  // string toolAddress = 3;
  void clear_tooladdress();
  const std::string& tooladdress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tooladdress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tooladdress();
  PROTOBUF_NODISCARD std::string* release_tooladdress();
  void set_allocated_tooladdress(std::string* tooladdress);
  private:
  const std::string& _internal_tooladdress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tooladdress(const std::string& value);
  std::string* _internal_mutable_tooladdress();
  public:

  // string ecuAddress = 4;
  void clear_ecuaddress();
  const std::string& ecuaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ecuaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ecuaddress();
  PROTOBUF_NODISCARD std::string* release_ecuaddress();
  void set_allocated_ecuaddress(std::string* ecuaddress);
  private:
  const std::string& _internal_ecuaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ecuaddress(const std::string& value);
  std::string* _internal_mutable_ecuaddress();
  public:

  // string resourceName = 6;
  void clear_resourcename();
  const std::string& resourcename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resourcename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resourcename();
  PROTOBUF_NODISCARD std::string* release_resourcename();
  void set_allocated_resourcename(std::string* resourcename);
  private:
  const std::string& _internal_resourcename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resourcename(const std::string& value);
  std::string* _internal_mutable_resourcename();
  public:

  // @@protoc_insertion_point(class_scope:translator.UDSOpenCommChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::translator::UDSCANFormat > canformat_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceno_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tooladdress_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ecuaddress_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resourcename_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_translator_2dprotobuf_2eproto;
};
// -------------------------------------------------------------------

class UDSOpenCommChannelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:translator.UDSOpenCommChannelResponse) */ {
 public:
  inline UDSOpenCommChannelResponse() : UDSOpenCommChannelResponse(nullptr) {}
  ~UDSOpenCommChannelResponse() override;
  explicit PROTOBUF_CONSTEXPR UDSOpenCommChannelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UDSOpenCommChannelResponse(const UDSOpenCommChannelResponse& from);
  UDSOpenCommChannelResponse(UDSOpenCommChannelResponse&& from) noexcept
    : UDSOpenCommChannelResponse() {
    *this = ::std::move(from);
  }

  inline UDSOpenCommChannelResponse& operator=(const UDSOpenCommChannelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDSOpenCommChannelResponse& operator=(UDSOpenCommChannelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UDSOpenCommChannelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDSOpenCommChannelResponse* internal_default_instance() {
    return reinterpret_cast<const UDSOpenCommChannelResponse*>(
               &_UDSOpenCommChannelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UDSOpenCommChannelResponse& a, UDSOpenCommChannelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UDSOpenCommChannelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDSOpenCommChannelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDSOpenCommChannelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDSOpenCommChannelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UDSOpenCommChannelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UDSOpenCommChannelResponse& from) {
    UDSOpenCommChannelResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UDSOpenCommChannelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "translator.UDSOpenCommChannelResponse";
  }
  protected:
  explicit UDSOpenCommChannelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIDFieldNumber = 1,
    kConnectionIDFieldNumber = 2,
    kSequenceNoFieldNumber = 3,
    kResponseCodeFieldNumber = 4,
  };
  // string appID = 1;
  void clear_appid();
  const std::string& appid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appid();
  PROTOBUF_NODISCARD std::string* release_appid();
  void set_allocated_appid(std::string* appid);
  private:
  const std::string& _internal_appid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appid(const std::string& value);
  std::string* _internal_mutable_appid();
  public:

  // string connectionID = 2;
  void clear_connectionid();
  const std::string& connectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectionid();
  PROTOBUF_NODISCARD std::string* release_connectionid();
  void set_allocated_connectionid(std::string* connectionid);
  private:
  const std::string& _internal_connectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectionid(const std::string& value);
  std::string* _internal_mutable_connectionid();
  public:

  // string sequenceNo = 3;
  void clear_sequenceno();
  const std::string& sequenceno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceno();
  PROTOBUF_NODISCARD std::string* release_sequenceno();
  void set_allocated_sequenceno(std::string* sequenceno);
  private:
  const std::string& _internal_sequenceno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceno(const std::string& value);
  std::string* _internal_mutable_sequenceno();
  public:

  // string responseCode = 4;
  void clear_responsecode();
  const std::string& responsecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_responsecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_responsecode();
  PROTOBUF_NODISCARD std::string* release_responsecode();
  void set_allocated_responsecode(std::string* responsecode);
  private:
  const std::string& _internal_responsecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsecode(const std::string& value);
  std::string* _internal_mutable_responsecode();
  public:

  // @@protoc_insertion_point(class_scope:translator.UDSOpenCommChannelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectionid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceno_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responsecode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_translator_2dprotobuf_2eproto;
};
// -------------------------------------------------------------------

class UDSCloseCommChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:translator.UDSCloseCommChannelRequest) */ {
 public:
  inline UDSCloseCommChannelRequest() : UDSCloseCommChannelRequest(nullptr) {}
  ~UDSCloseCommChannelRequest() override;
  explicit PROTOBUF_CONSTEXPR UDSCloseCommChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UDSCloseCommChannelRequest(const UDSCloseCommChannelRequest& from);
  UDSCloseCommChannelRequest(UDSCloseCommChannelRequest&& from) noexcept
    : UDSCloseCommChannelRequest() {
    *this = ::std::move(from);
  }

  inline UDSCloseCommChannelRequest& operator=(const UDSCloseCommChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDSCloseCommChannelRequest& operator=(UDSCloseCommChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UDSCloseCommChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDSCloseCommChannelRequest* internal_default_instance() {
    return reinterpret_cast<const UDSCloseCommChannelRequest*>(
               &_UDSCloseCommChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UDSCloseCommChannelRequest& a, UDSCloseCommChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UDSCloseCommChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDSCloseCommChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDSCloseCommChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDSCloseCommChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UDSCloseCommChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UDSCloseCommChannelRequest& from) {
    UDSCloseCommChannelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UDSCloseCommChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "translator.UDSCloseCommChannelRequest";
  }
  protected:
  explicit UDSCloseCommChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIDFieldNumber = 1,
    kConnectionIDFieldNumber = 2,
    kSequenceNoFieldNumber = 3,
  };
  // string appID = 1;
  void clear_appid();
  const std::string& appid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appid();
  PROTOBUF_NODISCARD std::string* release_appid();
  void set_allocated_appid(std::string* appid);
  private:
  const std::string& _internal_appid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appid(const std::string& value);
  std::string* _internal_mutable_appid();
  public:

  // string connectionID = 2;
  void clear_connectionid();
  const std::string& connectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectionid();
  PROTOBUF_NODISCARD std::string* release_connectionid();
  void set_allocated_connectionid(std::string* connectionid);
  private:
  const std::string& _internal_connectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectionid(const std::string& value);
  std::string* _internal_mutable_connectionid();
  public:

  // string sequenceNo = 3;
  void clear_sequenceno();
  const std::string& sequenceno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceno();
  PROTOBUF_NODISCARD std::string* release_sequenceno();
  void set_allocated_sequenceno(std::string* sequenceno);
  private:
  const std::string& _internal_sequenceno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceno(const std::string& value);
  std::string* _internal_mutable_sequenceno();
  public:

  // @@protoc_insertion_point(class_scope:translator.UDSCloseCommChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectionid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceno_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_translator_2dprotobuf_2eproto;
};
// -------------------------------------------------------------------

class UDSCloseCommChannelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:translator.UDSCloseCommChannelResponse) */ {
 public:
  inline UDSCloseCommChannelResponse() : UDSCloseCommChannelResponse(nullptr) {}
  ~UDSCloseCommChannelResponse() override;
  explicit PROTOBUF_CONSTEXPR UDSCloseCommChannelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UDSCloseCommChannelResponse(const UDSCloseCommChannelResponse& from);
  UDSCloseCommChannelResponse(UDSCloseCommChannelResponse&& from) noexcept
    : UDSCloseCommChannelResponse() {
    *this = ::std::move(from);
  }

  inline UDSCloseCommChannelResponse& operator=(const UDSCloseCommChannelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDSCloseCommChannelResponse& operator=(UDSCloseCommChannelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UDSCloseCommChannelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDSCloseCommChannelResponse* internal_default_instance() {
    return reinterpret_cast<const UDSCloseCommChannelResponse*>(
               &_UDSCloseCommChannelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UDSCloseCommChannelResponse& a, UDSCloseCommChannelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UDSCloseCommChannelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDSCloseCommChannelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDSCloseCommChannelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDSCloseCommChannelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UDSCloseCommChannelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UDSCloseCommChannelResponse& from) {
    UDSCloseCommChannelResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UDSCloseCommChannelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "translator.UDSCloseCommChannelResponse";
  }
  protected:
  explicit UDSCloseCommChannelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIDFieldNumber = 1,
    kConnectionIDFieldNumber = 2,
    kSequenceNoFieldNumber = 3,
    kResponseCodeFieldNumber = 4,
  };
  // string appID = 1;
  void clear_appid();
  const std::string& appid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appid();
  PROTOBUF_NODISCARD std::string* release_appid();
  void set_allocated_appid(std::string* appid);
  private:
  const std::string& _internal_appid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appid(const std::string& value);
  std::string* _internal_mutable_appid();
  public:

  // string connectionID = 2;
  void clear_connectionid();
  const std::string& connectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectionid();
  PROTOBUF_NODISCARD std::string* release_connectionid();
  void set_allocated_connectionid(std::string* connectionid);
  private:
  const std::string& _internal_connectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectionid(const std::string& value);
  std::string* _internal_mutable_connectionid();
  public:

  // string sequenceNo = 3;
  void clear_sequenceno();
  const std::string& sequenceno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceno();
  PROTOBUF_NODISCARD std::string* release_sequenceno();
  void set_allocated_sequenceno(std::string* sequenceno);
  private:
  const std::string& _internal_sequenceno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceno(const std::string& value);
  std::string* _internal_mutable_sequenceno();
  public:

  // string responseCode = 4;
  void clear_responsecode();
  const std::string& responsecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_responsecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_responsecode();
  PROTOBUF_NODISCARD std::string* release_responsecode();
  void set_allocated_responsecode(std::string* responsecode);
  private:
  const std::string& _internal_responsecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsecode(const std::string& value);
  std::string* _internal_mutable_responsecode();
  public:

  // @@protoc_insertion_point(class_scope:translator.UDSCloseCommChannelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectionid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceno_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responsecode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_translator_2dprotobuf_2eproto;
};
// -------------------------------------------------------------------

class ReadDataByIdentifierRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:translator.ReadDataByIdentifierRequest) */ {
 public:
  inline ReadDataByIdentifierRequest() : ReadDataByIdentifierRequest(nullptr) {}
  ~ReadDataByIdentifierRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadDataByIdentifierRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadDataByIdentifierRequest(const ReadDataByIdentifierRequest& from);
  ReadDataByIdentifierRequest(ReadDataByIdentifierRequest&& from) noexcept
    : ReadDataByIdentifierRequest() {
    *this = ::std::move(from);
  }

  inline ReadDataByIdentifierRequest& operator=(const ReadDataByIdentifierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadDataByIdentifierRequest& operator=(ReadDataByIdentifierRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadDataByIdentifierRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadDataByIdentifierRequest* internal_default_instance() {
    return reinterpret_cast<const ReadDataByIdentifierRequest*>(
               &_ReadDataByIdentifierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReadDataByIdentifierRequest& a, ReadDataByIdentifierRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadDataByIdentifierRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadDataByIdentifierRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadDataByIdentifierRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadDataByIdentifierRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadDataByIdentifierRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadDataByIdentifierRequest& from) {
    ReadDataByIdentifierRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadDataByIdentifierRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "translator.ReadDataByIdentifierRequest";
  }
  protected:
  explicit ReadDataByIdentifierRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDidFieldNumber = 4,
    kAppIDFieldNumber = 1,
    kConnectionIDFieldNumber = 2,
    kSequenceNoFieldNumber = 3,
  };
  // repeated string did = 4;
  int did_size() const;
  private:
  int _internal_did_size() const;
  public:
  void clear_did();
  const std::string& did(int index) const;
  std::string* mutable_did(int index);
  void set_did(int index, const std::string& value);
  void set_did(int index, std::string&& value);
  void set_did(int index, const char* value);
  void set_did(int index, const char* value, size_t size);
  std::string* add_did();
  void add_did(const std::string& value);
  void add_did(std::string&& value);
  void add_did(const char* value);
  void add_did(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& did() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_did();
  private:
  const std::string& _internal_did(int index) const;
  std::string* _internal_add_did();
  public:

  // string appID = 1;
  void clear_appid();
  const std::string& appid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appid();
  PROTOBUF_NODISCARD std::string* release_appid();
  void set_allocated_appid(std::string* appid);
  private:
  const std::string& _internal_appid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appid(const std::string& value);
  std::string* _internal_mutable_appid();
  public:

  // string connectionID = 2;
  void clear_connectionid();
  const std::string& connectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectionid();
  PROTOBUF_NODISCARD std::string* release_connectionid();
  void set_allocated_connectionid(std::string* connectionid);
  private:
  const std::string& _internal_connectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectionid(const std::string& value);
  std::string* _internal_mutable_connectionid();
  public:

  // string sequenceNo = 3;
  void clear_sequenceno();
  const std::string& sequenceno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceno();
  PROTOBUF_NODISCARD std::string* release_sequenceno();
  void set_allocated_sequenceno(std::string* sequenceno);
  private:
  const std::string& _internal_sequenceno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceno(const std::string& value);
  std::string* _internal_mutable_sequenceno();
  public:

  // @@protoc_insertion_point(class_scope:translator.ReadDataByIdentifierRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> did_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectionid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceno_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_translator_2dprotobuf_2eproto;
};
// -------------------------------------------------------------------

class ReadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:translator.ReadResponse) */ {
 public:
  inline ReadResponse() : ReadResponse(nullptr) {}
  ~ReadResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadResponse(const ReadResponse& from);
  ReadResponse(ReadResponse&& from) noexcept
    : ReadResponse() {
    *this = ::std::move(from);
  }

  inline ReadResponse& operator=(const ReadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadResponse& operator=(ReadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadResponse* internal_default_instance() {
    return reinterpret_cast<const ReadResponse*>(
               &_ReadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReadResponse& a, ReadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadResponse& from) {
    ReadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "translator.ReadResponse";
  }
  protected:
  explicit ReadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDidFieldNumber = 1,
    kValueFieldNumber = 2,
    kResponseCodeFieldNumber = 3,
  };
  // string did = 1;
  void clear_did();
  const std::string& did() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_did(ArgT0&& arg0, ArgT... args);
  std::string* mutable_did();
  PROTOBUF_NODISCARD std::string* release_did();
  void set_allocated_did(std::string* did);
  private:
  const std::string& _internal_did() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_did(const std::string& value);
  std::string* _internal_mutable_did();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string responseCode = 3;
  void clear_responsecode();
  const std::string& responsecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_responsecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_responsecode();
  PROTOBUF_NODISCARD std::string* release_responsecode();
  void set_allocated_responsecode(std::string* responsecode);
  private:
  const std::string& _internal_responsecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsecode(const std::string& value);
  std::string* _internal_mutable_responsecode();
  public:

  // @@protoc_insertion_point(class_scope:translator.ReadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr did_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responsecode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_translator_2dprotobuf_2eproto;
};
// -------------------------------------------------------------------

class ReadDataByIdentifierResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:translator.ReadDataByIdentifierResponse) */ {
 public:
  inline ReadDataByIdentifierResponse() : ReadDataByIdentifierResponse(nullptr) {}
  ~ReadDataByIdentifierResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadDataByIdentifierResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadDataByIdentifierResponse(const ReadDataByIdentifierResponse& from);
  ReadDataByIdentifierResponse(ReadDataByIdentifierResponse&& from) noexcept
    : ReadDataByIdentifierResponse() {
    *this = ::std::move(from);
  }

  inline ReadDataByIdentifierResponse& operator=(const ReadDataByIdentifierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadDataByIdentifierResponse& operator=(ReadDataByIdentifierResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadDataByIdentifierResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadDataByIdentifierResponse* internal_default_instance() {
    return reinterpret_cast<const ReadDataByIdentifierResponse*>(
               &_ReadDataByIdentifierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReadDataByIdentifierResponse& a, ReadDataByIdentifierResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadDataByIdentifierResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadDataByIdentifierResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadDataByIdentifierResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadDataByIdentifierResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadDataByIdentifierResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadDataByIdentifierResponse& from) {
    ReadDataByIdentifierResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadDataByIdentifierResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "translator.ReadDataByIdentifierResponse";
  }
  protected:
  explicit ReadDataByIdentifierResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kAppIDFieldNumber = 1,
    kConnectionIDFieldNumber = 2,
    kSequenceNoFieldNumber = 3,
    kResponseCodeFieldNumber = 5,
  };
  // repeated .translator.ReadResponse data = 4;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::translator::ReadResponse* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::translator::ReadResponse >*
      mutable_data();
  private:
  const ::translator::ReadResponse& _internal_data(int index) const;
  ::translator::ReadResponse* _internal_add_data();
  public:
  const ::translator::ReadResponse& data(int index) const;
  ::translator::ReadResponse* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::translator::ReadResponse >&
      data() const;

  // string appID = 1;
  void clear_appid();
  const std::string& appid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appid();
  PROTOBUF_NODISCARD std::string* release_appid();
  void set_allocated_appid(std::string* appid);
  private:
  const std::string& _internal_appid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appid(const std::string& value);
  std::string* _internal_mutable_appid();
  public:

  // string connectionID = 2;
  void clear_connectionid();
  const std::string& connectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectionid();
  PROTOBUF_NODISCARD std::string* release_connectionid();
  void set_allocated_connectionid(std::string* connectionid);
  private:
  const std::string& _internal_connectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectionid(const std::string& value);
  std::string* _internal_mutable_connectionid();
  public:

  // string sequenceNo = 3;
  void clear_sequenceno();
  const std::string& sequenceno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceno();
  PROTOBUF_NODISCARD std::string* release_sequenceno();
  void set_allocated_sequenceno(std::string* sequenceno);
  private:
  const std::string& _internal_sequenceno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceno(const std::string& value);
  std::string* _internal_mutable_sequenceno();
  public:

  // string responseCode = 5;
  void clear_responsecode();
  const std::string& responsecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_responsecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_responsecode();
  PROTOBUF_NODISCARD std::string* release_responsecode();
  void set_allocated_responsecode(std::string* responsecode);
  private:
  const std::string& _internal_responsecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsecode(const std::string& value);
  std::string* _internal_mutable_responsecode();
  public:

  // @@protoc_insertion_point(class_scope:translator.ReadDataByIdentifierResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::translator::ReadResponse > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectionid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceno_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responsecode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_translator_2dprotobuf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetClaimedAddressRequest

// string appID = 1;
inline void GetClaimedAddressRequest::clear_appid() {
  _impl_.appid_.ClearToEmpty();
}
inline const std::string& GetClaimedAddressRequest::appid() const {
  // @@protoc_insertion_point(field_get:translator.GetClaimedAddressRequest.appID)
  return _internal_appid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClaimedAddressRequest::set_appid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.GetClaimedAddressRequest.appID)
}
inline std::string* GetClaimedAddressRequest::mutable_appid() {
  std::string* _s = _internal_mutable_appid();
  // @@protoc_insertion_point(field_mutable:translator.GetClaimedAddressRequest.appID)
  return _s;
}
inline const std::string& GetClaimedAddressRequest::_internal_appid() const {
  return _impl_.appid_.Get();
}
inline void GetClaimedAddressRequest::_internal_set_appid(const std::string& value) {
  
  _impl_.appid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClaimedAddressRequest::_internal_mutable_appid() {
  
  return _impl_.appid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClaimedAddressRequest::release_appid() {
  // @@protoc_insertion_point(field_release:translator.GetClaimedAddressRequest.appID)
  return _impl_.appid_.Release();
}
inline void GetClaimedAddressRequest::set_allocated_appid(std::string* appid) {
  if (appid != nullptr) {
    
  } else {
    
  }
  _impl_.appid_.SetAllocated(appid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appid_.IsDefault()) {
    _impl_.appid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.GetClaimedAddressRequest.appID)
}

// string sequenceNo = 2;
inline void GetClaimedAddressRequest::clear_sequenceno() {
  _impl_.sequenceno_.ClearToEmpty();
}
inline const std::string& GetClaimedAddressRequest::sequenceno() const {
  // @@protoc_insertion_point(field_get:translator.GetClaimedAddressRequest.sequenceNo)
  return _internal_sequenceno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClaimedAddressRequest::set_sequenceno(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequenceno_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.GetClaimedAddressRequest.sequenceNo)
}
inline std::string* GetClaimedAddressRequest::mutable_sequenceno() {
  std::string* _s = _internal_mutable_sequenceno();
  // @@protoc_insertion_point(field_mutable:translator.GetClaimedAddressRequest.sequenceNo)
  return _s;
}
inline const std::string& GetClaimedAddressRequest::_internal_sequenceno() const {
  return _impl_.sequenceno_.Get();
}
inline void GetClaimedAddressRequest::_internal_set_sequenceno(const std::string& value) {
  
  _impl_.sequenceno_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClaimedAddressRequest::_internal_mutable_sequenceno() {
  
  return _impl_.sequenceno_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClaimedAddressRequest::release_sequenceno() {
  // @@protoc_insertion_point(field_release:translator.GetClaimedAddressRequest.sequenceNo)
  return _impl_.sequenceno_.Release();
}
inline void GetClaimedAddressRequest::set_allocated_sequenceno(std::string* sequenceno) {
  if (sequenceno != nullptr) {
    
  } else {
    
  }
  _impl_.sequenceno_.SetAllocated(sequenceno, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequenceno_.IsDefault()) {
    _impl_.sequenceno_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.GetClaimedAddressRequest.sequenceNo)
}

// -------------------------------------------------------------------

// GetClaimedAddressResponse

// string appID = 1;
inline void GetClaimedAddressResponse::clear_appid() {
  _impl_.appid_.ClearToEmpty();
}
inline const std::string& GetClaimedAddressResponse::appid() const {
  // @@protoc_insertion_point(field_get:translator.GetClaimedAddressResponse.appID)
  return _internal_appid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClaimedAddressResponse::set_appid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.GetClaimedAddressResponse.appID)
}
inline std::string* GetClaimedAddressResponse::mutable_appid() {
  std::string* _s = _internal_mutable_appid();
  // @@protoc_insertion_point(field_mutable:translator.GetClaimedAddressResponse.appID)
  return _s;
}
inline const std::string& GetClaimedAddressResponse::_internal_appid() const {
  return _impl_.appid_.Get();
}
inline void GetClaimedAddressResponse::_internal_set_appid(const std::string& value) {
  
  _impl_.appid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClaimedAddressResponse::_internal_mutable_appid() {
  
  return _impl_.appid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClaimedAddressResponse::release_appid() {
  // @@protoc_insertion_point(field_release:translator.GetClaimedAddressResponse.appID)
  return _impl_.appid_.Release();
}
inline void GetClaimedAddressResponse::set_allocated_appid(std::string* appid) {
  if (appid != nullptr) {
    
  } else {
    
  }
  _impl_.appid_.SetAllocated(appid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appid_.IsDefault()) {
    _impl_.appid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.GetClaimedAddressResponse.appID)
}

// string sequenceNo = 2;
inline void GetClaimedAddressResponse::clear_sequenceno() {
  _impl_.sequenceno_.ClearToEmpty();
}
inline const std::string& GetClaimedAddressResponse::sequenceno() const {
  // @@protoc_insertion_point(field_get:translator.GetClaimedAddressResponse.sequenceNo)
  return _internal_sequenceno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClaimedAddressResponse::set_sequenceno(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequenceno_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.GetClaimedAddressResponse.sequenceNo)
}
inline std::string* GetClaimedAddressResponse::mutable_sequenceno() {
  std::string* _s = _internal_mutable_sequenceno();
  // @@protoc_insertion_point(field_mutable:translator.GetClaimedAddressResponse.sequenceNo)
  return _s;
}
inline const std::string& GetClaimedAddressResponse::_internal_sequenceno() const {
  return _impl_.sequenceno_.Get();
}
inline void GetClaimedAddressResponse::_internal_set_sequenceno(const std::string& value) {
  
  _impl_.sequenceno_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClaimedAddressResponse::_internal_mutable_sequenceno() {
  
  return _impl_.sequenceno_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClaimedAddressResponse::release_sequenceno() {
  // @@protoc_insertion_point(field_release:translator.GetClaimedAddressResponse.sequenceNo)
  return _impl_.sequenceno_.Release();
}
inline void GetClaimedAddressResponse::set_allocated_sequenceno(std::string* sequenceno) {
  if (sequenceno != nullptr) {
    
  } else {
    
  }
  _impl_.sequenceno_.SetAllocated(sequenceno, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequenceno_.IsDefault()) {
    _impl_.sequenceno_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.GetClaimedAddressResponse.sequenceNo)
}

// string claimedAddress = 3;
inline void GetClaimedAddressResponse::clear_claimedaddress() {
  _impl_.claimedaddress_.ClearToEmpty();
}
inline const std::string& GetClaimedAddressResponse::claimedaddress() const {
  // @@protoc_insertion_point(field_get:translator.GetClaimedAddressResponse.claimedAddress)
  return _internal_claimedaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClaimedAddressResponse::set_claimedaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.claimedaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.GetClaimedAddressResponse.claimedAddress)
}
inline std::string* GetClaimedAddressResponse::mutable_claimedaddress() {
  std::string* _s = _internal_mutable_claimedaddress();
  // @@protoc_insertion_point(field_mutable:translator.GetClaimedAddressResponse.claimedAddress)
  return _s;
}
inline const std::string& GetClaimedAddressResponse::_internal_claimedaddress() const {
  return _impl_.claimedaddress_.Get();
}
inline void GetClaimedAddressResponse::_internal_set_claimedaddress(const std::string& value) {
  
  _impl_.claimedaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClaimedAddressResponse::_internal_mutable_claimedaddress() {
  
  return _impl_.claimedaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClaimedAddressResponse::release_claimedaddress() {
  // @@protoc_insertion_point(field_release:translator.GetClaimedAddressResponse.claimedAddress)
  return _impl_.claimedaddress_.Release();
}
inline void GetClaimedAddressResponse::set_allocated_claimedaddress(std::string* claimedaddress) {
  if (claimedaddress != nullptr) {
    
  } else {
    
  }
  _impl_.claimedaddress_.SetAllocated(claimedaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.claimedaddress_.IsDefault()) {
    _impl_.claimedaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.GetClaimedAddressResponse.claimedAddress)
}

// string responseCode = 4;
inline void GetClaimedAddressResponse::clear_responsecode() {
  _impl_.responsecode_.ClearToEmpty();
}
inline const std::string& GetClaimedAddressResponse::responsecode() const {
  // @@protoc_insertion_point(field_get:translator.GetClaimedAddressResponse.responseCode)
  return _internal_responsecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClaimedAddressResponse::set_responsecode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.responsecode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.GetClaimedAddressResponse.responseCode)
}
inline std::string* GetClaimedAddressResponse::mutable_responsecode() {
  std::string* _s = _internal_mutable_responsecode();
  // @@protoc_insertion_point(field_mutable:translator.GetClaimedAddressResponse.responseCode)
  return _s;
}
inline const std::string& GetClaimedAddressResponse::_internal_responsecode() const {
  return _impl_.responsecode_.Get();
}
inline void GetClaimedAddressResponse::_internal_set_responsecode(const std::string& value) {
  
  _impl_.responsecode_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClaimedAddressResponse::_internal_mutable_responsecode() {
  
  return _impl_.responsecode_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClaimedAddressResponse::release_responsecode() {
  // @@protoc_insertion_point(field_release:translator.GetClaimedAddressResponse.responseCode)
  return _impl_.responsecode_.Release();
}
inline void GetClaimedAddressResponse::set_allocated_responsecode(std::string* responsecode) {
  if (responsecode != nullptr) {
    
  } else {
    
  }
  _impl_.responsecode_.SetAllocated(responsecode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.responsecode_.IsDefault()) {
    _impl_.responsecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.GetClaimedAddressResponse.responseCode)
}

// -------------------------------------------------------------------

// UDSCANFormat

// string canPhysReqFormat = 1;
inline void UDSCANFormat::clear_canphysreqformat() {
  _impl_.canphysreqformat_.ClearToEmpty();
}
inline const std::string& UDSCANFormat::canphysreqformat() const {
  // @@protoc_insertion_point(field_get:translator.UDSCANFormat.canPhysReqFormat)
  return _internal_canphysreqformat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSCANFormat::set_canphysreqformat(ArgT0&& arg0, ArgT... args) {
 
 _impl_.canphysreqformat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSCANFormat.canPhysReqFormat)
}
inline std::string* UDSCANFormat::mutable_canphysreqformat() {
  std::string* _s = _internal_mutable_canphysreqformat();
  // @@protoc_insertion_point(field_mutable:translator.UDSCANFormat.canPhysReqFormat)
  return _s;
}
inline const std::string& UDSCANFormat::_internal_canphysreqformat() const {
  return _impl_.canphysreqformat_.Get();
}
inline void UDSCANFormat::_internal_set_canphysreqformat(const std::string& value) {
  
  _impl_.canphysreqformat_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSCANFormat::_internal_mutable_canphysreqformat() {
  
  return _impl_.canphysreqformat_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSCANFormat::release_canphysreqformat() {
  // @@protoc_insertion_point(field_release:translator.UDSCANFormat.canPhysReqFormat)
  return _impl_.canphysreqformat_.Release();
}
inline void UDSCANFormat::set_allocated_canphysreqformat(std::string* canphysreqformat) {
  if (canphysreqformat != nullptr) {
    
  } else {
    
  }
  _impl_.canphysreqformat_.SetAllocated(canphysreqformat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.canphysreqformat_.IsDefault()) {
    _impl_.canphysreqformat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSCANFormat.canPhysReqFormat)
}

// string canRespUSDTFormat = 2;
inline void UDSCANFormat::clear_canrespusdtformat() {
  _impl_.canrespusdtformat_.ClearToEmpty();
}
inline const std::string& UDSCANFormat::canrespusdtformat() const {
  // @@protoc_insertion_point(field_get:translator.UDSCANFormat.canRespUSDTFormat)
  return _internal_canrespusdtformat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSCANFormat::set_canrespusdtformat(ArgT0&& arg0, ArgT... args) {
 
 _impl_.canrespusdtformat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSCANFormat.canRespUSDTFormat)
}
inline std::string* UDSCANFormat::mutable_canrespusdtformat() {
  std::string* _s = _internal_mutable_canrespusdtformat();
  // @@protoc_insertion_point(field_mutable:translator.UDSCANFormat.canRespUSDTFormat)
  return _s;
}
inline const std::string& UDSCANFormat::_internal_canrespusdtformat() const {
  return _impl_.canrespusdtformat_.Get();
}
inline void UDSCANFormat::_internal_set_canrespusdtformat(const std::string& value) {
  
  _impl_.canrespusdtformat_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSCANFormat::_internal_mutable_canrespusdtformat() {
  
  return _impl_.canrespusdtformat_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSCANFormat::release_canrespusdtformat() {
  // @@protoc_insertion_point(field_release:translator.UDSCANFormat.canRespUSDTFormat)
  return _impl_.canrespusdtformat_.Release();
}
inline void UDSCANFormat::set_allocated_canrespusdtformat(std::string* canrespusdtformat) {
  if (canrespusdtformat != nullptr) {
    
  } else {
    
  }
  _impl_.canrespusdtformat_.SetAllocated(canrespusdtformat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.canrespusdtformat_.IsDefault()) {
    _impl_.canrespusdtformat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSCANFormat.canRespUSDTFormat)
}

// -------------------------------------------------------------------

// UDSOpenCommChannelRequest

// string appID = 1;
inline void UDSOpenCommChannelRequest::clear_appid() {
  _impl_.appid_.ClearToEmpty();
}
inline const std::string& UDSOpenCommChannelRequest::appid() const {
  // @@protoc_insertion_point(field_get:translator.UDSOpenCommChannelRequest.appID)
  return _internal_appid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSOpenCommChannelRequest::set_appid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSOpenCommChannelRequest.appID)
}
inline std::string* UDSOpenCommChannelRequest::mutable_appid() {
  std::string* _s = _internal_mutable_appid();
  // @@protoc_insertion_point(field_mutable:translator.UDSOpenCommChannelRequest.appID)
  return _s;
}
inline const std::string& UDSOpenCommChannelRequest::_internal_appid() const {
  return _impl_.appid_.Get();
}
inline void UDSOpenCommChannelRequest::_internal_set_appid(const std::string& value) {
  
  _impl_.appid_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelRequest::_internal_mutable_appid() {
  
  return _impl_.appid_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelRequest::release_appid() {
  // @@protoc_insertion_point(field_release:translator.UDSOpenCommChannelRequest.appID)
  return _impl_.appid_.Release();
}
inline void UDSOpenCommChannelRequest::set_allocated_appid(std::string* appid) {
  if (appid != nullptr) {
    
  } else {
    
  }
  _impl_.appid_.SetAllocated(appid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appid_.IsDefault()) {
    _impl_.appid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSOpenCommChannelRequest.appID)
}

// string sequenceNo = 2;
inline void UDSOpenCommChannelRequest::clear_sequenceno() {
  _impl_.sequenceno_.ClearToEmpty();
}
inline const std::string& UDSOpenCommChannelRequest::sequenceno() const {
  // @@protoc_insertion_point(field_get:translator.UDSOpenCommChannelRequest.sequenceNo)
  return _internal_sequenceno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSOpenCommChannelRequest::set_sequenceno(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequenceno_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSOpenCommChannelRequest.sequenceNo)
}
inline std::string* UDSOpenCommChannelRequest::mutable_sequenceno() {
  std::string* _s = _internal_mutable_sequenceno();
  // @@protoc_insertion_point(field_mutable:translator.UDSOpenCommChannelRequest.sequenceNo)
  return _s;
}
inline const std::string& UDSOpenCommChannelRequest::_internal_sequenceno() const {
  return _impl_.sequenceno_.Get();
}
inline void UDSOpenCommChannelRequest::_internal_set_sequenceno(const std::string& value) {
  
  _impl_.sequenceno_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelRequest::_internal_mutable_sequenceno() {
  
  return _impl_.sequenceno_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelRequest::release_sequenceno() {
  // @@protoc_insertion_point(field_release:translator.UDSOpenCommChannelRequest.sequenceNo)
  return _impl_.sequenceno_.Release();
}
inline void UDSOpenCommChannelRequest::set_allocated_sequenceno(std::string* sequenceno) {
  if (sequenceno != nullptr) {
    
  } else {
    
  }
  _impl_.sequenceno_.SetAllocated(sequenceno, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequenceno_.IsDefault()) {
    _impl_.sequenceno_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSOpenCommChannelRequest.sequenceNo)
}

// string toolAddress = 3;
inline void UDSOpenCommChannelRequest::clear_tooladdress() {
  _impl_.tooladdress_.ClearToEmpty();
}
inline const std::string& UDSOpenCommChannelRequest::tooladdress() const {
  // @@protoc_insertion_point(field_get:translator.UDSOpenCommChannelRequest.toolAddress)
  return _internal_tooladdress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSOpenCommChannelRequest::set_tooladdress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tooladdress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSOpenCommChannelRequest.toolAddress)
}
inline std::string* UDSOpenCommChannelRequest::mutable_tooladdress() {
  std::string* _s = _internal_mutable_tooladdress();
  // @@protoc_insertion_point(field_mutable:translator.UDSOpenCommChannelRequest.toolAddress)
  return _s;
}
inline const std::string& UDSOpenCommChannelRequest::_internal_tooladdress() const {
  return _impl_.tooladdress_.Get();
}
inline void UDSOpenCommChannelRequest::_internal_set_tooladdress(const std::string& value) {
  
  _impl_.tooladdress_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelRequest::_internal_mutable_tooladdress() {
  
  return _impl_.tooladdress_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelRequest::release_tooladdress() {
  // @@protoc_insertion_point(field_release:translator.UDSOpenCommChannelRequest.toolAddress)
  return _impl_.tooladdress_.Release();
}
inline void UDSOpenCommChannelRequest::set_allocated_tooladdress(std::string* tooladdress) {
  if (tooladdress != nullptr) {
    
  } else {
    
  }
  _impl_.tooladdress_.SetAllocated(tooladdress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tooladdress_.IsDefault()) {
    _impl_.tooladdress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSOpenCommChannelRequest.toolAddress)
}

// string ecuAddress = 4;
inline void UDSOpenCommChannelRequest::clear_ecuaddress() {
  _impl_.ecuaddress_.ClearToEmpty();
}
inline const std::string& UDSOpenCommChannelRequest::ecuaddress() const {
  // @@protoc_insertion_point(field_get:translator.UDSOpenCommChannelRequest.ecuAddress)
  return _internal_ecuaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSOpenCommChannelRequest::set_ecuaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ecuaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSOpenCommChannelRequest.ecuAddress)
}
inline std::string* UDSOpenCommChannelRequest::mutable_ecuaddress() {
  std::string* _s = _internal_mutable_ecuaddress();
  // @@protoc_insertion_point(field_mutable:translator.UDSOpenCommChannelRequest.ecuAddress)
  return _s;
}
inline const std::string& UDSOpenCommChannelRequest::_internal_ecuaddress() const {
  return _impl_.ecuaddress_.Get();
}
inline void UDSOpenCommChannelRequest::_internal_set_ecuaddress(const std::string& value) {
  
  _impl_.ecuaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelRequest::_internal_mutable_ecuaddress() {
  
  return _impl_.ecuaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelRequest::release_ecuaddress() {
  // @@protoc_insertion_point(field_release:translator.UDSOpenCommChannelRequest.ecuAddress)
  return _impl_.ecuaddress_.Release();
}
inline void UDSOpenCommChannelRequest::set_allocated_ecuaddress(std::string* ecuaddress) {
  if (ecuaddress != nullptr) {
    
  } else {
    
  }
  _impl_.ecuaddress_.SetAllocated(ecuaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ecuaddress_.IsDefault()) {
    _impl_.ecuaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSOpenCommChannelRequest.ecuAddress)
}

// repeated .translator.UDSCANFormat canFormat = 5;
inline int UDSOpenCommChannelRequest::_internal_canformat_size() const {
  return _impl_.canformat_.size();
}
inline int UDSOpenCommChannelRequest::canformat_size() const {
  return _internal_canformat_size();
}
inline void UDSOpenCommChannelRequest::clear_canformat() {
  _impl_.canformat_.Clear();
}
inline ::translator::UDSCANFormat* UDSOpenCommChannelRequest::mutable_canformat(int index) {
  // @@protoc_insertion_point(field_mutable:translator.UDSOpenCommChannelRequest.canFormat)
  return _impl_.canformat_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::translator::UDSCANFormat >*
UDSOpenCommChannelRequest::mutable_canformat() {
  // @@protoc_insertion_point(field_mutable_list:translator.UDSOpenCommChannelRequest.canFormat)
  return &_impl_.canformat_;
}
inline const ::translator::UDSCANFormat& UDSOpenCommChannelRequest::_internal_canformat(int index) const {
  return _impl_.canformat_.Get(index);
}
inline const ::translator::UDSCANFormat& UDSOpenCommChannelRequest::canformat(int index) const {
  // @@protoc_insertion_point(field_get:translator.UDSOpenCommChannelRequest.canFormat)
  return _internal_canformat(index);
}
inline ::translator::UDSCANFormat* UDSOpenCommChannelRequest::_internal_add_canformat() {
  return _impl_.canformat_.Add();
}
inline ::translator::UDSCANFormat* UDSOpenCommChannelRequest::add_canformat() {
  ::translator::UDSCANFormat* _add = _internal_add_canformat();
  // @@protoc_insertion_point(field_add:translator.UDSOpenCommChannelRequest.canFormat)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::translator::UDSCANFormat >&
UDSOpenCommChannelRequest::canformat() const {
  // @@protoc_insertion_point(field_list:translator.UDSOpenCommChannelRequest.canFormat)
  return _impl_.canformat_;
}

// string resourceName = 6;
inline void UDSOpenCommChannelRequest::clear_resourcename() {
  _impl_.resourcename_.ClearToEmpty();
}
inline const std::string& UDSOpenCommChannelRequest::resourcename() const {
  // @@protoc_insertion_point(field_get:translator.UDSOpenCommChannelRequest.resourceName)
  return _internal_resourcename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSOpenCommChannelRequest::set_resourcename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resourcename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSOpenCommChannelRequest.resourceName)
}
inline std::string* UDSOpenCommChannelRequest::mutable_resourcename() {
  std::string* _s = _internal_mutable_resourcename();
  // @@protoc_insertion_point(field_mutable:translator.UDSOpenCommChannelRequest.resourceName)
  return _s;
}
inline const std::string& UDSOpenCommChannelRequest::_internal_resourcename() const {
  return _impl_.resourcename_.Get();
}
inline void UDSOpenCommChannelRequest::_internal_set_resourcename(const std::string& value) {
  
  _impl_.resourcename_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelRequest::_internal_mutable_resourcename() {
  
  return _impl_.resourcename_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelRequest::release_resourcename() {
  // @@protoc_insertion_point(field_release:translator.UDSOpenCommChannelRequest.resourceName)
  return _impl_.resourcename_.Release();
}
inline void UDSOpenCommChannelRequest::set_allocated_resourcename(std::string* resourcename) {
  if (resourcename != nullptr) {
    
  } else {
    
  }
  _impl_.resourcename_.SetAllocated(resourcename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourcename_.IsDefault()) {
    _impl_.resourcename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSOpenCommChannelRequest.resourceName)
}

// -------------------------------------------------------------------

// UDSOpenCommChannelResponse

// string appID = 1;
inline void UDSOpenCommChannelResponse::clear_appid() {
  _impl_.appid_.ClearToEmpty();
}
inline const std::string& UDSOpenCommChannelResponse::appid() const {
  // @@protoc_insertion_point(field_get:translator.UDSOpenCommChannelResponse.appID)
  return _internal_appid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSOpenCommChannelResponse::set_appid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSOpenCommChannelResponse.appID)
}
inline std::string* UDSOpenCommChannelResponse::mutable_appid() {
  std::string* _s = _internal_mutable_appid();
  // @@protoc_insertion_point(field_mutable:translator.UDSOpenCommChannelResponse.appID)
  return _s;
}
inline const std::string& UDSOpenCommChannelResponse::_internal_appid() const {
  return _impl_.appid_.Get();
}
inline void UDSOpenCommChannelResponse::_internal_set_appid(const std::string& value) {
  
  _impl_.appid_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelResponse::_internal_mutable_appid() {
  
  return _impl_.appid_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelResponse::release_appid() {
  // @@protoc_insertion_point(field_release:translator.UDSOpenCommChannelResponse.appID)
  return _impl_.appid_.Release();
}
inline void UDSOpenCommChannelResponse::set_allocated_appid(std::string* appid) {
  if (appid != nullptr) {
    
  } else {
    
  }
  _impl_.appid_.SetAllocated(appid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appid_.IsDefault()) {
    _impl_.appid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSOpenCommChannelResponse.appID)
}

// string connectionID = 2;
inline void UDSOpenCommChannelResponse::clear_connectionid() {
  _impl_.connectionid_.ClearToEmpty();
}
inline const std::string& UDSOpenCommChannelResponse::connectionid() const {
  // @@protoc_insertion_point(field_get:translator.UDSOpenCommChannelResponse.connectionID)
  return _internal_connectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSOpenCommChannelResponse::set_connectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSOpenCommChannelResponse.connectionID)
}
inline std::string* UDSOpenCommChannelResponse::mutable_connectionid() {
  std::string* _s = _internal_mutable_connectionid();
  // @@protoc_insertion_point(field_mutable:translator.UDSOpenCommChannelResponse.connectionID)
  return _s;
}
inline const std::string& UDSOpenCommChannelResponse::_internal_connectionid() const {
  return _impl_.connectionid_.Get();
}
inline void UDSOpenCommChannelResponse::_internal_set_connectionid(const std::string& value) {
  
  _impl_.connectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelResponse::_internal_mutable_connectionid() {
  
  return _impl_.connectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelResponse::release_connectionid() {
  // @@protoc_insertion_point(field_release:translator.UDSOpenCommChannelResponse.connectionID)
  return _impl_.connectionid_.Release();
}
inline void UDSOpenCommChannelResponse::set_allocated_connectionid(std::string* connectionid) {
  if (connectionid != nullptr) {
    
  } else {
    
  }
  _impl_.connectionid_.SetAllocated(connectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connectionid_.IsDefault()) {
    _impl_.connectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSOpenCommChannelResponse.connectionID)
}

// string sequenceNo = 3;
inline void UDSOpenCommChannelResponse::clear_sequenceno() {
  _impl_.sequenceno_.ClearToEmpty();
}
inline const std::string& UDSOpenCommChannelResponse::sequenceno() const {
  // @@protoc_insertion_point(field_get:translator.UDSOpenCommChannelResponse.sequenceNo)
  return _internal_sequenceno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSOpenCommChannelResponse::set_sequenceno(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequenceno_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSOpenCommChannelResponse.sequenceNo)
}
inline std::string* UDSOpenCommChannelResponse::mutable_sequenceno() {
  std::string* _s = _internal_mutable_sequenceno();
  // @@protoc_insertion_point(field_mutable:translator.UDSOpenCommChannelResponse.sequenceNo)
  return _s;
}
inline const std::string& UDSOpenCommChannelResponse::_internal_sequenceno() const {
  return _impl_.sequenceno_.Get();
}
inline void UDSOpenCommChannelResponse::_internal_set_sequenceno(const std::string& value) {
  
  _impl_.sequenceno_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelResponse::_internal_mutable_sequenceno() {
  
  return _impl_.sequenceno_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelResponse::release_sequenceno() {
  // @@protoc_insertion_point(field_release:translator.UDSOpenCommChannelResponse.sequenceNo)
  return _impl_.sequenceno_.Release();
}
inline void UDSOpenCommChannelResponse::set_allocated_sequenceno(std::string* sequenceno) {
  if (sequenceno != nullptr) {
    
  } else {
    
  }
  _impl_.sequenceno_.SetAllocated(sequenceno, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequenceno_.IsDefault()) {
    _impl_.sequenceno_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSOpenCommChannelResponse.sequenceNo)
}

// string responseCode = 4;
inline void UDSOpenCommChannelResponse::clear_responsecode() {
  _impl_.responsecode_.ClearToEmpty();
}
inline const std::string& UDSOpenCommChannelResponse::responsecode() const {
  // @@protoc_insertion_point(field_get:translator.UDSOpenCommChannelResponse.responseCode)
  return _internal_responsecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSOpenCommChannelResponse::set_responsecode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.responsecode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSOpenCommChannelResponse.responseCode)
}
inline std::string* UDSOpenCommChannelResponse::mutable_responsecode() {
  std::string* _s = _internal_mutable_responsecode();
  // @@protoc_insertion_point(field_mutable:translator.UDSOpenCommChannelResponse.responseCode)
  return _s;
}
inline const std::string& UDSOpenCommChannelResponse::_internal_responsecode() const {
  return _impl_.responsecode_.Get();
}
inline void UDSOpenCommChannelResponse::_internal_set_responsecode(const std::string& value) {
  
  _impl_.responsecode_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelResponse::_internal_mutable_responsecode() {
  
  return _impl_.responsecode_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSOpenCommChannelResponse::release_responsecode() {
  // @@protoc_insertion_point(field_release:translator.UDSOpenCommChannelResponse.responseCode)
  return _impl_.responsecode_.Release();
}
inline void UDSOpenCommChannelResponse::set_allocated_responsecode(std::string* responsecode) {
  if (responsecode != nullptr) {
    
  } else {
    
  }
  _impl_.responsecode_.SetAllocated(responsecode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.responsecode_.IsDefault()) {
    _impl_.responsecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSOpenCommChannelResponse.responseCode)
}

// -------------------------------------------------------------------

// UDSCloseCommChannelRequest

// string appID = 1;
inline void UDSCloseCommChannelRequest::clear_appid() {
  _impl_.appid_.ClearToEmpty();
}
inline const std::string& UDSCloseCommChannelRequest::appid() const {
  // @@protoc_insertion_point(field_get:translator.UDSCloseCommChannelRequest.appID)
  return _internal_appid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSCloseCommChannelRequest::set_appid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSCloseCommChannelRequest.appID)
}
inline std::string* UDSCloseCommChannelRequest::mutable_appid() {
  std::string* _s = _internal_mutable_appid();
  // @@protoc_insertion_point(field_mutable:translator.UDSCloseCommChannelRequest.appID)
  return _s;
}
inline const std::string& UDSCloseCommChannelRequest::_internal_appid() const {
  return _impl_.appid_.Get();
}
inline void UDSCloseCommChannelRequest::_internal_set_appid(const std::string& value) {
  
  _impl_.appid_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelRequest::_internal_mutable_appid() {
  
  return _impl_.appid_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelRequest::release_appid() {
  // @@protoc_insertion_point(field_release:translator.UDSCloseCommChannelRequest.appID)
  return _impl_.appid_.Release();
}
inline void UDSCloseCommChannelRequest::set_allocated_appid(std::string* appid) {
  if (appid != nullptr) {
    
  } else {
    
  }
  _impl_.appid_.SetAllocated(appid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appid_.IsDefault()) {
    _impl_.appid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSCloseCommChannelRequest.appID)
}

// string connectionID = 2;
inline void UDSCloseCommChannelRequest::clear_connectionid() {
  _impl_.connectionid_.ClearToEmpty();
}
inline const std::string& UDSCloseCommChannelRequest::connectionid() const {
  // @@protoc_insertion_point(field_get:translator.UDSCloseCommChannelRequest.connectionID)
  return _internal_connectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSCloseCommChannelRequest::set_connectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSCloseCommChannelRequest.connectionID)
}
inline std::string* UDSCloseCommChannelRequest::mutable_connectionid() {
  std::string* _s = _internal_mutable_connectionid();
  // @@protoc_insertion_point(field_mutable:translator.UDSCloseCommChannelRequest.connectionID)
  return _s;
}
inline const std::string& UDSCloseCommChannelRequest::_internal_connectionid() const {
  return _impl_.connectionid_.Get();
}
inline void UDSCloseCommChannelRequest::_internal_set_connectionid(const std::string& value) {
  
  _impl_.connectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelRequest::_internal_mutable_connectionid() {
  
  return _impl_.connectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelRequest::release_connectionid() {
  // @@protoc_insertion_point(field_release:translator.UDSCloseCommChannelRequest.connectionID)
  return _impl_.connectionid_.Release();
}
inline void UDSCloseCommChannelRequest::set_allocated_connectionid(std::string* connectionid) {
  if (connectionid != nullptr) {
    
  } else {
    
  }
  _impl_.connectionid_.SetAllocated(connectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connectionid_.IsDefault()) {
    _impl_.connectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSCloseCommChannelRequest.connectionID)
}

// string sequenceNo = 3;
inline void UDSCloseCommChannelRequest::clear_sequenceno() {
  _impl_.sequenceno_.ClearToEmpty();
}
inline const std::string& UDSCloseCommChannelRequest::sequenceno() const {
  // @@protoc_insertion_point(field_get:translator.UDSCloseCommChannelRequest.sequenceNo)
  return _internal_sequenceno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSCloseCommChannelRequest::set_sequenceno(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequenceno_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSCloseCommChannelRequest.sequenceNo)
}
inline std::string* UDSCloseCommChannelRequest::mutable_sequenceno() {
  std::string* _s = _internal_mutable_sequenceno();
  // @@protoc_insertion_point(field_mutable:translator.UDSCloseCommChannelRequest.sequenceNo)
  return _s;
}
inline const std::string& UDSCloseCommChannelRequest::_internal_sequenceno() const {
  return _impl_.sequenceno_.Get();
}
inline void UDSCloseCommChannelRequest::_internal_set_sequenceno(const std::string& value) {
  
  _impl_.sequenceno_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelRequest::_internal_mutable_sequenceno() {
  
  return _impl_.sequenceno_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelRequest::release_sequenceno() {
  // @@protoc_insertion_point(field_release:translator.UDSCloseCommChannelRequest.sequenceNo)
  return _impl_.sequenceno_.Release();
}
inline void UDSCloseCommChannelRequest::set_allocated_sequenceno(std::string* sequenceno) {
  if (sequenceno != nullptr) {
    
  } else {
    
  }
  _impl_.sequenceno_.SetAllocated(sequenceno, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequenceno_.IsDefault()) {
    _impl_.sequenceno_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSCloseCommChannelRequest.sequenceNo)
}

// -------------------------------------------------------------------

// UDSCloseCommChannelResponse

// string appID = 1;
inline void UDSCloseCommChannelResponse::clear_appid() {
  _impl_.appid_.ClearToEmpty();
}
inline const std::string& UDSCloseCommChannelResponse::appid() const {
  // @@protoc_insertion_point(field_get:translator.UDSCloseCommChannelResponse.appID)
  return _internal_appid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSCloseCommChannelResponse::set_appid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSCloseCommChannelResponse.appID)
}
inline std::string* UDSCloseCommChannelResponse::mutable_appid() {
  std::string* _s = _internal_mutable_appid();
  // @@protoc_insertion_point(field_mutable:translator.UDSCloseCommChannelResponse.appID)
  return _s;
}
inline const std::string& UDSCloseCommChannelResponse::_internal_appid() const {
  return _impl_.appid_.Get();
}
inline void UDSCloseCommChannelResponse::_internal_set_appid(const std::string& value) {
  
  _impl_.appid_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelResponse::_internal_mutable_appid() {
  
  return _impl_.appid_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelResponse::release_appid() {
  // @@protoc_insertion_point(field_release:translator.UDSCloseCommChannelResponse.appID)
  return _impl_.appid_.Release();
}
inline void UDSCloseCommChannelResponse::set_allocated_appid(std::string* appid) {
  if (appid != nullptr) {
    
  } else {
    
  }
  _impl_.appid_.SetAllocated(appid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appid_.IsDefault()) {
    _impl_.appid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSCloseCommChannelResponse.appID)
}

// string connectionID = 2;
inline void UDSCloseCommChannelResponse::clear_connectionid() {
  _impl_.connectionid_.ClearToEmpty();
}
inline const std::string& UDSCloseCommChannelResponse::connectionid() const {
  // @@protoc_insertion_point(field_get:translator.UDSCloseCommChannelResponse.connectionID)
  return _internal_connectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSCloseCommChannelResponse::set_connectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSCloseCommChannelResponse.connectionID)
}
inline std::string* UDSCloseCommChannelResponse::mutable_connectionid() {
  std::string* _s = _internal_mutable_connectionid();
  // @@protoc_insertion_point(field_mutable:translator.UDSCloseCommChannelResponse.connectionID)
  return _s;
}
inline const std::string& UDSCloseCommChannelResponse::_internal_connectionid() const {
  return _impl_.connectionid_.Get();
}
inline void UDSCloseCommChannelResponse::_internal_set_connectionid(const std::string& value) {
  
  _impl_.connectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelResponse::_internal_mutable_connectionid() {
  
  return _impl_.connectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelResponse::release_connectionid() {
  // @@protoc_insertion_point(field_release:translator.UDSCloseCommChannelResponse.connectionID)
  return _impl_.connectionid_.Release();
}
inline void UDSCloseCommChannelResponse::set_allocated_connectionid(std::string* connectionid) {
  if (connectionid != nullptr) {
    
  } else {
    
  }
  _impl_.connectionid_.SetAllocated(connectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connectionid_.IsDefault()) {
    _impl_.connectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSCloseCommChannelResponse.connectionID)
}

// string sequenceNo = 3;
inline void UDSCloseCommChannelResponse::clear_sequenceno() {
  _impl_.sequenceno_.ClearToEmpty();
}
inline const std::string& UDSCloseCommChannelResponse::sequenceno() const {
  // @@protoc_insertion_point(field_get:translator.UDSCloseCommChannelResponse.sequenceNo)
  return _internal_sequenceno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSCloseCommChannelResponse::set_sequenceno(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequenceno_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSCloseCommChannelResponse.sequenceNo)
}
inline std::string* UDSCloseCommChannelResponse::mutable_sequenceno() {
  std::string* _s = _internal_mutable_sequenceno();
  // @@protoc_insertion_point(field_mutable:translator.UDSCloseCommChannelResponse.sequenceNo)
  return _s;
}
inline const std::string& UDSCloseCommChannelResponse::_internal_sequenceno() const {
  return _impl_.sequenceno_.Get();
}
inline void UDSCloseCommChannelResponse::_internal_set_sequenceno(const std::string& value) {
  
  _impl_.sequenceno_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelResponse::_internal_mutable_sequenceno() {
  
  return _impl_.sequenceno_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelResponse::release_sequenceno() {
  // @@protoc_insertion_point(field_release:translator.UDSCloseCommChannelResponse.sequenceNo)
  return _impl_.sequenceno_.Release();
}
inline void UDSCloseCommChannelResponse::set_allocated_sequenceno(std::string* sequenceno) {
  if (sequenceno != nullptr) {
    
  } else {
    
  }
  _impl_.sequenceno_.SetAllocated(sequenceno, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequenceno_.IsDefault()) {
    _impl_.sequenceno_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSCloseCommChannelResponse.sequenceNo)
}

// string responseCode = 4;
inline void UDSCloseCommChannelResponse::clear_responsecode() {
  _impl_.responsecode_.ClearToEmpty();
}
inline const std::string& UDSCloseCommChannelResponse::responsecode() const {
  // @@protoc_insertion_point(field_get:translator.UDSCloseCommChannelResponse.responseCode)
  return _internal_responsecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDSCloseCommChannelResponse::set_responsecode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.responsecode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.UDSCloseCommChannelResponse.responseCode)
}
inline std::string* UDSCloseCommChannelResponse::mutable_responsecode() {
  std::string* _s = _internal_mutable_responsecode();
  // @@protoc_insertion_point(field_mutable:translator.UDSCloseCommChannelResponse.responseCode)
  return _s;
}
inline const std::string& UDSCloseCommChannelResponse::_internal_responsecode() const {
  return _impl_.responsecode_.Get();
}
inline void UDSCloseCommChannelResponse::_internal_set_responsecode(const std::string& value) {
  
  _impl_.responsecode_.Set(value, GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelResponse::_internal_mutable_responsecode() {
  
  return _impl_.responsecode_.Mutable(GetArenaForAllocation());
}
inline std::string* UDSCloseCommChannelResponse::release_responsecode() {
  // @@protoc_insertion_point(field_release:translator.UDSCloseCommChannelResponse.responseCode)
  return _impl_.responsecode_.Release();
}
inline void UDSCloseCommChannelResponse::set_allocated_responsecode(std::string* responsecode) {
  if (responsecode != nullptr) {
    
  } else {
    
  }
  _impl_.responsecode_.SetAllocated(responsecode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.responsecode_.IsDefault()) {
    _impl_.responsecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.UDSCloseCommChannelResponse.responseCode)
}

// -------------------------------------------------------------------

// ReadDataByIdentifierRequest

// string appID = 1;
inline void ReadDataByIdentifierRequest::clear_appid() {
  _impl_.appid_.ClearToEmpty();
}
inline const std::string& ReadDataByIdentifierRequest::appid() const {
  // @@protoc_insertion_point(field_get:translator.ReadDataByIdentifierRequest.appID)
  return _internal_appid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadDataByIdentifierRequest::set_appid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.ReadDataByIdentifierRequest.appID)
}
inline std::string* ReadDataByIdentifierRequest::mutable_appid() {
  std::string* _s = _internal_mutable_appid();
  // @@protoc_insertion_point(field_mutable:translator.ReadDataByIdentifierRequest.appID)
  return _s;
}
inline const std::string& ReadDataByIdentifierRequest::_internal_appid() const {
  return _impl_.appid_.Get();
}
inline void ReadDataByIdentifierRequest::_internal_set_appid(const std::string& value) {
  
  _impl_.appid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierRequest::_internal_mutable_appid() {
  
  return _impl_.appid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierRequest::release_appid() {
  // @@protoc_insertion_point(field_release:translator.ReadDataByIdentifierRequest.appID)
  return _impl_.appid_.Release();
}
inline void ReadDataByIdentifierRequest::set_allocated_appid(std::string* appid) {
  if (appid != nullptr) {
    
  } else {
    
  }
  _impl_.appid_.SetAllocated(appid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appid_.IsDefault()) {
    _impl_.appid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.ReadDataByIdentifierRequest.appID)
}

// string connectionID = 2;
inline void ReadDataByIdentifierRequest::clear_connectionid() {
  _impl_.connectionid_.ClearToEmpty();
}
inline const std::string& ReadDataByIdentifierRequest::connectionid() const {
  // @@protoc_insertion_point(field_get:translator.ReadDataByIdentifierRequest.connectionID)
  return _internal_connectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadDataByIdentifierRequest::set_connectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.ReadDataByIdentifierRequest.connectionID)
}
inline std::string* ReadDataByIdentifierRequest::mutable_connectionid() {
  std::string* _s = _internal_mutable_connectionid();
  // @@protoc_insertion_point(field_mutable:translator.ReadDataByIdentifierRequest.connectionID)
  return _s;
}
inline const std::string& ReadDataByIdentifierRequest::_internal_connectionid() const {
  return _impl_.connectionid_.Get();
}
inline void ReadDataByIdentifierRequest::_internal_set_connectionid(const std::string& value) {
  
  _impl_.connectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierRequest::_internal_mutable_connectionid() {
  
  return _impl_.connectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierRequest::release_connectionid() {
  // @@protoc_insertion_point(field_release:translator.ReadDataByIdentifierRequest.connectionID)
  return _impl_.connectionid_.Release();
}
inline void ReadDataByIdentifierRequest::set_allocated_connectionid(std::string* connectionid) {
  if (connectionid != nullptr) {
    
  } else {
    
  }
  _impl_.connectionid_.SetAllocated(connectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connectionid_.IsDefault()) {
    _impl_.connectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.ReadDataByIdentifierRequest.connectionID)
}

// string sequenceNo = 3;
inline void ReadDataByIdentifierRequest::clear_sequenceno() {
  _impl_.sequenceno_.ClearToEmpty();
}
inline const std::string& ReadDataByIdentifierRequest::sequenceno() const {
  // @@protoc_insertion_point(field_get:translator.ReadDataByIdentifierRequest.sequenceNo)
  return _internal_sequenceno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadDataByIdentifierRequest::set_sequenceno(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequenceno_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.ReadDataByIdentifierRequest.sequenceNo)
}
inline std::string* ReadDataByIdentifierRequest::mutable_sequenceno() {
  std::string* _s = _internal_mutable_sequenceno();
  // @@protoc_insertion_point(field_mutable:translator.ReadDataByIdentifierRequest.sequenceNo)
  return _s;
}
inline const std::string& ReadDataByIdentifierRequest::_internal_sequenceno() const {
  return _impl_.sequenceno_.Get();
}
inline void ReadDataByIdentifierRequest::_internal_set_sequenceno(const std::string& value) {
  
  _impl_.sequenceno_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierRequest::_internal_mutable_sequenceno() {
  
  return _impl_.sequenceno_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierRequest::release_sequenceno() {
  // @@protoc_insertion_point(field_release:translator.ReadDataByIdentifierRequest.sequenceNo)
  return _impl_.sequenceno_.Release();
}
inline void ReadDataByIdentifierRequest::set_allocated_sequenceno(std::string* sequenceno) {
  if (sequenceno != nullptr) {
    
  } else {
    
  }
  _impl_.sequenceno_.SetAllocated(sequenceno, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequenceno_.IsDefault()) {
    _impl_.sequenceno_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.ReadDataByIdentifierRequest.sequenceNo)
}

// repeated string did = 4;
inline int ReadDataByIdentifierRequest::_internal_did_size() const {
  return _impl_.did_.size();
}
inline int ReadDataByIdentifierRequest::did_size() const {
  return _internal_did_size();
}
inline void ReadDataByIdentifierRequest::clear_did() {
  _impl_.did_.Clear();
}
inline std::string* ReadDataByIdentifierRequest::add_did() {
  std::string* _s = _internal_add_did();
  // @@protoc_insertion_point(field_add_mutable:translator.ReadDataByIdentifierRequest.did)
  return _s;
}
inline const std::string& ReadDataByIdentifierRequest::_internal_did(int index) const {
  return _impl_.did_.Get(index);
}
inline const std::string& ReadDataByIdentifierRequest::did(int index) const {
  // @@protoc_insertion_point(field_get:translator.ReadDataByIdentifierRequest.did)
  return _internal_did(index);
}
inline std::string* ReadDataByIdentifierRequest::mutable_did(int index) {
  // @@protoc_insertion_point(field_mutable:translator.ReadDataByIdentifierRequest.did)
  return _impl_.did_.Mutable(index);
}
inline void ReadDataByIdentifierRequest::set_did(int index, const std::string& value) {
  _impl_.did_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:translator.ReadDataByIdentifierRequest.did)
}
inline void ReadDataByIdentifierRequest::set_did(int index, std::string&& value) {
  _impl_.did_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:translator.ReadDataByIdentifierRequest.did)
}
inline void ReadDataByIdentifierRequest::set_did(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.did_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:translator.ReadDataByIdentifierRequest.did)
}
inline void ReadDataByIdentifierRequest::set_did(int index, const char* value, size_t size) {
  _impl_.did_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:translator.ReadDataByIdentifierRequest.did)
}
inline std::string* ReadDataByIdentifierRequest::_internal_add_did() {
  return _impl_.did_.Add();
}
inline void ReadDataByIdentifierRequest::add_did(const std::string& value) {
  _impl_.did_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:translator.ReadDataByIdentifierRequest.did)
}
inline void ReadDataByIdentifierRequest::add_did(std::string&& value) {
  _impl_.did_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:translator.ReadDataByIdentifierRequest.did)
}
inline void ReadDataByIdentifierRequest::add_did(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.did_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:translator.ReadDataByIdentifierRequest.did)
}
inline void ReadDataByIdentifierRequest::add_did(const char* value, size_t size) {
  _impl_.did_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:translator.ReadDataByIdentifierRequest.did)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ReadDataByIdentifierRequest::did() const {
  // @@protoc_insertion_point(field_list:translator.ReadDataByIdentifierRequest.did)
  return _impl_.did_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ReadDataByIdentifierRequest::mutable_did() {
  // @@protoc_insertion_point(field_mutable_list:translator.ReadDataByIdentifierRequest.did)
  return &_impl_.did_;
}

// -------------------------------------------------------------------

// ReadResponse

// string did = 1;
inline void ReadResponse::clear_did() {
  _impl_.did_.ClearToEmpty();
}
inline const std::string& ReadResponse::did() const {
  // @@protoc_insertion_point(field_get:translator.ReadResponse.did)
  return _internal_did();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadResponse::set_did(ArgT0&& arg0, ArgT... args) {
 
 _impl_.did_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.ReadResponse.did)
}
inline std::string* ReadResponse::mutable_did() {
  std::string* _s = _internal_mutable_did();
  // @@protoc_insertion_point(field_mutable:translator.ReadResponse.did)
  return _s;
}
inline const std::string& ReadResponse::_internal_did() const {
  return _impl_.did_.Get();
}
inline void ReadResponse::_internal_set_did(const std::string& value) {
  
  _impl_.did_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadResponse::_internal_mutable_did() {
  
  return _impl_.did_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadResponse::release_did() {
  // @@protoc_insertion_point(field_release:translator.ReadResponse.did)
  return _impl_.did_.Release();
}
inline void ReadResponse::set_allocated_did(std::string* did) {
  if (did != nullptr) {
    
  } else {
    
  }
  _impl_.did_.SetAllocated(did, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.did_.IsDefault()) {
    _impl_.did_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.ReadResponse.did)
}

// string value = 2;
inline void ReadResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ReadResponse::value() const {
  // @@protoc_insertion_point(field_get:translator.ReadResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadResponse::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.ReadResponse.value)
}
inline std::string* ReadResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:translator.ReadResponse.value)
  return _s;
}
inline const std::string& ReadResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void ReadResponse::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadResponse::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadResponse::release_value() {
  // @@protoc_insertion_point(field_release:translator.ReadResponse.value)
  return _impl_.value_.Release();
}
inline void ReadResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.ReadResponse.value)
}

// string responseCode = 3;
inline void ReadResponse::clear_responsecode() {
  _impl_.responsecode_.ClearToEmpty();
}
inline const std::string& ReadResponse::responsecode() const {
  // @@protoc_insertion_point(field_get:translator.ReadResponse.responseCode)
  return _internal_responsecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadResponse::set_responsecode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.responsecode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.ReadResponse.responseCode)
}
inline std::string* ReadResponse::mutable_responsecode() {
  std::string* _s = _internal_mutable_responsecode();
  // @@protoc_insertion_point(field_mutable:translator.ReadResponse.responseCode)
  return _s;
}
inline const std::string& ReadResponse::_internal_responsecode() const {
  return _impl_.responsecode_.Get();
}
inline void ReadResponse::_internal_set_responsecode(const std::string& value) {
  
  _impl_.responsecode_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadResponse::_internal_mutable_responsecode() {
  
  return _impl_.responsecode_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadResponse::release_responsecode() {
  // @@protoc_insertion_point(field_release:translator.ReadResponse.responseCode)
  return _impl_.responsecode_.Release();
}
inline void ReadResponse::set_allocated_responsecode(std::string* responsecode) {
  if (responsecode != nullptr) {
    
  } else {
    
  }
  _impl_.responsecode_.SetAllocated(responsecode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.responsecode_.IsDefault()) {
    _impl_.responsecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.ReadResponse.responseCode)
}

// -------------------------------------------------------------------

// ReadDataByIdentifierResponse

// string appID = 1;
inline void ReadDataByIdentifierResponse::clear_appid() {
  _impl_.appid_.ClearToEmpty();
}
inline const std::string& ReadDataByIdentifierResponse::appid() const {
  // @@protoc_insertion_point(field_get:translator.ReadDataByIdentifierResponse.appID)
  return _internal_appid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadDataByIdentifierResponse::set_appid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.ReadDataByIdentifierResponse.appID)
}
inline std::string* ReadDataByIdentifierResponse::mutable_appid() {
  std::string* _s = _internal_mutable_appid();
  // @@protoc_insertion_point(field_mutable:translator.ReadDataByIdentifierResponse.appID)
  return _s;
}
inline const std::string& ReadDataByIdentifierResponse::_internal_appid() const {
  return _impl_.appid_.Get();
}
inline void ReadDataByIdentifierResponse::_internal_set_appid(const std::string& value) {
  
  _impl_.appid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierResponse::_internal_mutable_appid() {
  
  return _impl_.appid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierResponse::release_appid() {
  // @@protoc_insertion_point(field_release:translator.ReadDataByIdentifierResponse.appID)
  return _impl_.appid_.Release();
}
inline void ReadDataByIdentifierResponse::set_allocated_appid(std::string* appid) {
  if (appid != nullptr) {
    
  } else {
    
  }
  _impl_.appid_.SetAllocated(appid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appid_.IsDefault()) {
    _impl_.appid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.ReadDataByIdentifierResponse.appID)
}

// string connectionID = 2;
inline void ReadDataByIdentifierResponse::clear_connectionid() {
  _impl_.connectionid_.ClearToEmpty();
}
inline const std::string& ReadDataByIdentifierResponse::connectionid() const {
  // @@protoc_insertion_point(field_get:translator.ReadDataByIdentifierResponse.connectionID)
  return _internal_connectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadDataByIdentifierResponse::set_connectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.ReadDataByIdentifierResponse.connectionID)
}
inline std::string* ReadDataByIdentifierResponse::mutable_connectionid() {
  std::string* _s = _internal_mutable_connectionid();
  // @@protoc_insertion_point(field_mutable:translator.ReadDataByIdentifierResponse.connectionID)
  return _s;
}
inline const std::string& ReadDataByIdentifierResponse::_internal_connectionid() const {
  return _impl_.connectionid_.Get();
}
inline void ReadDataByIdentifierResponse::_internal_set_connectionid(const std::string& value) {
  
  _impl_.connectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierResponse::_internal_mutable_connectionid() {
  
  return _impl_.connectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierResponse::release_connectionid() {
  // @@protoc_insertion_point(field_release:translator.ReadDataByIdentifierResponse.connectionID)
  return _impl_.connectionid_.Release();
}
inline void ReadDataByIdentifierResponse::set_allocated_connectionid(std::string* connectionid) {
  if (connectionid != nullptr) {
    
  } else {
    
  }
  _impl_.connectionid_.SetAllocated(connectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connectionid_.IsDefault()) {
    _impl_.connectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.ReadDataByIdentifierResponse.connectionID)
}

// string sequenceNo = 3;
inline void ReadDataByIdentifierResponse::clear_sequenceno() {
  _impl_.sequenceno_.ClearToEmpty();
}
inline const std::string& ReadDataByIdentifierResponse::sequenceno() const {
  // @@protoc_insertion_point(field_get:translator.ReadDataByIdentifierResponse.sequenceNo)
  return _internal_sequenceno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadDataByIdentifierResponse::set_sequenceno(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequenceno_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.ReadDataByIdentifierResponse.sequenceNo)
}
inline std::string* ReadDataByIdentifierResponse::mutable_sequenceno() {
  std::string* _s = _internal_mutable_sequenceno();
  // @@protoc_insertion_point(field_mutable:translator.ReadDataByIdentifierResponse.sequenceNo)
  return _s;
}
inline const std::string& ReadDataByIdentifierResponse::_internal_sequenceno() const {
  return _impl_.sequenceno_.Get();
}
inline void ReadDataByIdentifierResponse::_internal_set_sequenceno(const std::string& value) {
  
  _impl_.sequenceno_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierResponse::_internal_mutable_sequenceno() {
  
  return _impl_.sequenceno_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierResponse::release_sequenceno() {
  // @@protoc_insertion_point(field_release:translator.ReadDataByIdentifierResponse.sequenceNo)
  return _impl_.sequenceno_.Release();
}
inline void ReadDataByIdentifierResponse::set_allocated_sequenceno(std::string* sequenceno) {
  if (sequenceno != nullptr) {
    
  } else {
    
  }
  _impl_.sequenceno_.SetAllocated(sequenceno, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequenceno_.IsDefault()) {
    _impl_.sequenceno_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.ReadDataByIdentifierResponse.sequenceNo)
}

// repeated .translator.ReadResponse data = 4;
inline int ReadDataByIdentifierResponse::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int ReadDataByIdentifierResponse::data_size() const {
  return _internal_data_size();
}
inline void ReadDataByIdentifierResponse::clear_data() {
  _impl_.data_.Clear();
}
inline ::translator::ReadResponse* ReadDataByIdentifierResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:translator.ReadDataByIdentifierResponse.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::translator::ReadResponse >*
ReadDataByIdentifierResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:translator.ReadDataByIdentifierResponse.data)
  return &_impl_.data_;
}
inline const ::translator::ReadResponse& ReadDataByIdentifierResponse::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::translator::ReadResponse& ReadDataByIdentifierResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:translator.ReadDataByIdentifierResponse.data)
  return _internal_data(index);
}
inline ::translator::ReadResponse* ReadDataByIdentifierResponse::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::translator::ReadResponse* ReadDataByIdentifierResponse::add_data() {
  ::translator::ReadResponse* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:translator.ReadDataByIdentifierResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::translator::ReadResponse >&
ReadDataByIdentifierResponse::data() const {
  // @@protoc_insertion_point(field_list:translator.ReadDataByIdentifierResponse.data)
  return _impl_.data_;
}

// string responseCode = 5;
inline void ReadDataByIdentifierResponse::clear_responsecode() {
  _impl_.responsecode_.ClearToEmpty();
}
inline const std::string& ReadDataByIdentifierResponse::responsecode() const {
  // @@protoc_insertion_point(field_get:translator.ReadDataByIdentifierResponse.responseCode)
  return _internal_responsecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadDataByIdentifierResponse::set_responsecode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.responsecode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:translator.ReadDataByIdentifierResponse.responseCode)
}
inline std::string* ReadDataByIdentifierResponse::mutable_responsecode() {
  std::string* _s = _internal_mutable_responsecode();
  // @@protoc_insertion_point(field_mutable:translator.ReadDataByIdentifierResponse.responseCode)
  return _s;
}
inline const std::string& ReadDataByIdentifierResponse::_internal_responsecode() const {
  return _impl_.responsecode_.Get();
}
inline void ReadDataByIdentifierResponse::_internal_set_responsecode(const std::string& value) {
  
  _impl_.responsecode_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierResponse::_internal_mutable_responsecode() {
  
  return _impl_.responsecode_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadDataByIdentifierResponse::release_responsecode() {
  // @@protoc_insertion_point(field_release:translator.ReadDataByIdentifierResponse.responseCode)
  return _impl_.responsecode_.Release();
}
inline void ReadDataByIdentifierResponse::set_allocated_responsecode(std::string* responsecode) {
  if (responsecode != nullptr) {
    
  } else {
    
  }
  _impl_.responsecode_.SetAllocated(responsecode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.responsecode_.IsDefault()) {
    _impl_.responsecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:translator.ReadDataByIdentifierResponse.responseCode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace translator

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_translator_2dprotobuf_2eproto
